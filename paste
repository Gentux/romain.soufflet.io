
# Conventions Forge DNUM

## Reviews

La merge request doit contenir une description claire du contenu de celle-ci
ainsi que des instructions pour effectuer des tests.

Le plan de test effectué par le Committer doit également figurer si celui-ci est
manuel et non automatique (pipeline).

1. Committer : Créer une MR à partir de la branche de développement vers
develop.
2. Committer : Demander des reviewers en partageant le lien de la MR dans le
tchat.
3. Reviewer : Commenter de manière bienveillante et cordiale en mettant les
formes.
4. Committer/reviewer : Echanger pour se mettre d'accord.
5. Reviewer : Clore les threads qu'il a ouverts lorsqu'un accord est trouvé
(réponse au commentaire ou modification apportée satisfaisante) et Valider la
MR avec un clic sur :thumbsup: .
6. Committer : Merger la MR lorsque celle-ci est validée par les reviewers.

> Les patchs lors de la review doivent être envoyés sous forme de commit de
> fixup mais il faut penser à squasher tous les commits de fixup avant de merger
> sur la branche develop.

> Note: on conseille d'envoyer les merge requests le plus tôt possible afin
> de récupérer des retours rapidement. Cela permet d'éviter que le reviewer
> demande des changements conséquents au dernier moment qui peuvent impacter
> la date de livraison.

---

## Git

Les commits doivent être le plus unitaires possible. Chaque commit doit être
fonctionnel sans tirer des dépendances. On doit pouvoir créer une release à
partir de chaque commit. Cela permet de faciliter les reverts et les
cherry-pick d'une branche à l'autre car cela réduit les risques de conflit.

> Attention avant de merger à lancer les deux commandes suivantes et à ne jamais
> faire de force push. Il faut toujours utiliser le rebase et jamais le merge.
> ```
> 1. git rebase -i origin/develop --autosquash
> 2. git push origin dev_branch:develop --dry-run`
> ```

Les messages de commit doivent être structurés comme suit :

> \<type\> (scope): \<description\>
>
> [Issue: ISSUE_NUMBER]
>
> [commentaires optionnels]

Le scope peut être :

* Le nom du layer impacté dans frg-provisioning (frg-layer-fws...).
* Le micro-service impacté dans forgedc-webservice (Webservice, Healthcheck...).
* Le nom du playbook ou service ou fonctionnalité impactée dans forgedc-core
(Scripts, Skydns, Redis...).

Les messages de commit doivent toujours commencer par une majuscule et la
ligne première ne doit pas contenir plus de 80 caractères.

Ne jamais merger de commit de fixup, ils doivent être squashés avant de merger
sur la branche cible (develop ou master).

Les messages de commit des fixups doivent être structurés comme suit :

> fixup! message_de_commit_du_commit_a_fixer

> Note : pour les commits dans d'autres dépôts que `forgedc-core`, il faut
> penser à indiquer la référence complète du ticket (exemple :
> `forgedc/forgedc-core#500`).

### Documents de référence

- https://www.conventionalcommits.org/fr/v1.0.0-beta.3/

---

## Python

On utilise Python 3.8, il est conseillé d'utiliser un environnement virtuel
afin de s'assurer d'avoir la bonne version de Python et des modules nécessaires.

### Linters

- `PyLint`
- `Pyflakes`
- `MacCabe`

### Documents de référence

- https://www.python.org/dev/peps/pep-0008/

### Règles spécifiques

#### Les chaînes de caractères :

- Les simples guillemets sont la règle. On utilise les double guillemets
qu'en cas de besoin pour ajouter des simples ou des doubles guillemets dans la
chaîne de caractères en question.
- Pour le formatage, on privilégie la forme `'blabla-%s-blabla' % 'xxx'`. Mais
la fonction `format` peut être utilisée si besoin pour une chaîne de caractères
existante.
- Il faut utiliser la fonction `join` uniquement pour une chaîne de caractères
existante que l'on souhaite étendre avec une liste mais surtout pas pour le
formatage.

#### Retours à la ligne

- Il faut configurer les linters et les éditeurs de code à 80 caractères maximum
par ligne.
- Il faut rester sur la même ligne autant que possible tout en respectant la
limite des 80 caractères et l'indentation.
- Les indentations sont constituées de 4 espaces.

Exemple :

```python
def __get_server_name(appli, layer, release, tenant, base_image_name=None):
    if appli == 'forge' and layer == 'baseimage':
        return appli.join([SERVER_PREFIX, get_alias(appli, layer,
                                                    release, tenant),
                          __get_os_name(base_image_name)])
    return layer.join([SERVER_PREFIX, get_alias(appli, layer, release, tenant)])
```

- Une ligne ne peut pas contenir uniquement `):` ni `:` pour la déclaration
d'une fonction donc le dernier paramètre (ici base_image_name) doit être mis
sur la ligne suivante. Pour les appels des fonctions, la même règle s'applique,
la parenthèse fermante ne doit pas se retrouver sur une ligne seule.

```python
def __get_keyname(appli, layer, release, tenant, username,
                  base_image_name=None):
    if appli == 'forge' and layer == 'baseimage':
        return appli.join([get_alias(appli, layer, release, tenant), username,
                          __get_os_name(base_image_name)])
    return layer.join([get_alias(appli, layer, release, tenant), username])
```

---

## YAML

- Il faut configurer les linters et les éditeurs de code à 80 caractères maximum
par ligne.
- Les indentations sont constituées de 2 espaces.

### Linter

- `yamllint`

### Documents de référence

- https://docs.ansible.com/ansible/latest/reference_appendices/YAMLSyntax.html

---

## Dockerfile

- Les indentations sont constituées de 4 espaces.

Il faut surtout garder en tête que dans un Dockerfile chaque instruction
constitue un layer et plus il y a des layers, plus la taille de l'image est
importante. Donc il faut limiter au maximum le nombre de layers en regroupant
les instructions par fonction ou action.

Exemple :

```
RUN mkdir -p /src \
    && mkdir -p /etc/frg-webservice \
    && mkdir -p /var/forge/log/webservice \
    && touch /var/forge/log/webservice/gunicorn.access.log \
    && touch /var/forge/log/webservice/gunicorn.error.log
```

> Toutes les commandes sur une seule instruction `RUN` et non pas une commande
> par instruction.

Pensez à toujours variabiliser vos images de bases afin d'éviter de générer
des nouveaux commits juste pour une mise à jour :

```
ARG image_base_name=python
ARG image_base_version=3.5
FROM $image_base_name:$image_base_version
```

> Cela permet de changer l'image de base lors du `docker build` facilement :

> ```
> --build-arg image_base_name=nexus.forge-dc.cloudmi.minint.fr/python
> --build-arg image_base_name=3.8
> ```

Pensez à toujours ajouter les 3 lignes suivantes dans vos Dockerfile :

```
ARG GIT_COMMIT=dirty
LABEL git_commit=$GIT_COMMIT
LABEL maintainer="Forge dnum forge-dsic@interieur.gouv.fr"
```

> Sans oublier de passer la variable GIT_COMMIT lors du docker build

Pensez a différencier vos besoins lors des stages de `build` et de `run`.
Par exemple, la plupart du temps, on a besoin d'un proxy http au `build` mais
pas au `run` car on souhaite installer des dépendances au `build` mais l'image
n'a pas besoin de communiquer sur internet au `run`. La bonne façon de faire est
de passer les proxies http en `build-arg` au lieu de variable d'environnement
qui seront persitentes au `run` et visibles lors d'un `docker inspect` de votre
image.

Exemple de build avec les variables uniquement nécessaires à ce stage :

```
docker build \
		-f frg_webservice/Dockerfile \
		--build-arg GIT_COMMIT=$(COMMIT) \
		--build-arg http_proxy=${http_proxy} \
		--build-arg https_proxy=${https_proxy} \
		--build-arg no_proxy=${no_proxy} \
		--build-arg image_base_name=nexus.forge-dc.cloudmi.minint.fr/python \
		--tag frg-webservice .
```

Exemple de run avec les variables uniquement nécessaires à ce stage :

```
docker run \
		--name Webservice \
		--env-file ${FRG_CONFIG_DIR}/frg-webservice.conf \
		--publish 0.0.0.0:5000:5000 \
		--network webservice-subnet \
		-e REDIS_HOST=Redis \
		-e ENABLE_DEBUG=True \
		--volume ${FRG_CONFIG_DIR}/clouds.yaml:/etc/openstack/clouds.yaml \
		--volume ${FRG_CONFIG_DIR}/pi.crt:/etc/frg-webservice/pi.crt \
		--volume ${PWD}/logs:/var/forge/log/webservice \
		--volume ${PWD}/frg_webservice:/src/frg_webservice \
		--detach \
		frg-webservice
```

> Il ne sert absolument à rien de prende une image de base légère (alpine par
> exemple), si c'est pour installer tous les paquets debian ensuite. Autant
> prendre une image de base debian directement. On aura l'avantage de diminuer
> le temps de build à défaut de diminuer la taille de l'image.

### Documents de référence

- https://docs.docker.com/develop/develop-images/dockerfile_best-practices/
